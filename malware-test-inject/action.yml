name: 'Malware Test Injection'
description: 'Inject known malware samples into package ecosystems for security testing'
author: 'Unknown Cyber Inc.'

branding:
  icon: 'alert-triangle'
  color: 'red'

inputs:
  api-key:
    description: 'UnknownCyber API key for downloading samples'
    required: true
  
  ecosystem:
    description: 'Package ecosystem (npm, pip, maven, cargo, go, ruby, nuget)'
    required: false
    default: 'npm'
  
  package-name:
    description: 'Name of the fake infected package to create'
    required: false
    default: 'test-malware-sample'
  
  package-version:
    description: 'Version of the fake infected package'
    required: false
    default: '1.0.0-infected'
  
  samples:
    description: 'Comma-separated list of sample types to download (obfuscated-js,elf-malware,pe-malware,all)'
    required: false
    default: 'all'
  
  target-path:
    description: 'Base path for package installation (e.g., node_modules, site-packages, etc.)'
    required: false
    default: ''
  
  enabled:
    description: 'Whether to actually inject samples (useful for conditional execution)'
    required: false
    default: 'true'

outputs:
  injected-path:
    description: 'Path where malware samples were injected'
    value: ${{ steps.inject.outputs.path }}
  
  samples-count:
    description: 'Number of samples successfully injected'
    value: ${{ steps.inject.outputs.count }}
  
  sample-files:
    description: 'Comma-separated list of injected sample files'
    value: ${{ steps.inject.outputs.files }}

runs:
  using: 'composite'
  steps:
    - name: Inject malware test samples
      id: inject
      if: inputs.enabled == 'true'
      shell: bash
      env:
        UC_API_KEY: ${{ inputs.api-key }}
        ECOSYSTEM: ${{ inputs.ecosystem }}
        PKG_NAME: ${{ inputs.package-name }}
        PKG_VERSION: ${{ inputs.package-version }}
        SAMPLES: ${{ inputs.samples }}
        TARGET_PATH: ${{ inputs.target-path }}
      run: |
        set -e
        
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        echo "â•‘           MALWARE TEST INJECTION - FOR TESTING ONLY                   â•‘"
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        
        # Determine target directory based on ecosystem
        case "$ECOSYSTEM" in
          npm)
            BASE_PATH="${TARGET_PATH:-node_modules}"
            PKG_DIR="$BASE_PATH/$PKG_NAME"
            ;;
          pip)
            BASE_PATH="${TARGET_PATH:-site-packages}"
            PKG_DIR="$BASE_PATH/$PKG_NAME"
            ;;
          maven)
            BASE_PATH="${TARGET_PATH:-.m2/repository}"
            # Maven uses group/artifact/version structure
            PKG_DIR="$BASE_PATH/com/test/$PKG_NAME/$PKG_VERSION"
            ;;
          cargo)
            BASE_PATH="${TARGET_PATH:-target/release}"
            PKG_DIR="$BASE_PATH"
            ;;
          go)
            BASE_PATH="${TARGET_PATH:-vendor}"
            PKG_DIR="$BASE_PATH/github.com/test/$PKG_NAME"
            ;;
          ruby)
            BASE_PATH="${TARGET_PATH:-vendor/bundle}"
            PKG_DIR="$BASE_PATH/ruby/gems/$PKG_NAME-$PKG_VERSION"
            ;;
          nuget)
            BASE_PATH="${TARGET_PATH:-packages}"
            PKG_DIR="$BASE_PATH/$PKG_NAME/$PKG_VERSION"
            ;;
          generic|*)
            BASE_PATH="${TARGET_PATH:-.}"
            PKG_DIR="$BASE_PATH/$PKG_NAME"
            ;;
        esac
        
        echo "Ecosystem: $ECOSYSTEM"
        echo "Package: $PKG_NAME@$PKG_VERSION"
        echo "Target directory: $PKG_DIR"
        echo ""
        
        # Create package directory
        mkdir -p "$PKG_DIR"
        
        # Create ecosystem-specific metadata file
        case "$ECOSYSTEM" in
          npm)
            cat > "$PKG_DIR/package.json" << EOF
        {
          "name": "$PKG_NAME",
          "version": "$PKG_VERSION",
          "description": "MALWARE TEST SAMPLE - DO NOT USE IN PRODUCTION",
          "main": "index.js",
          "_warning": "This package contains malware samples for security testing"
        }
        EOF
            ;;
          pip)
            mkdir -p "$PKG_DIR/${PKG_NAME//-/_}.dist-info"
            cat > "$PKG_DIR/${PKG_NAME//-/_}.dist-info/METADATA" << EOF
        Metadata-Version: 2.1
        Name: $PKG_NAME
        Version: $PKG_VERSION
        Summary: MALWARE TEST SAMPLE - DO NOT USE IN PRODUCTION
        EOF
            ;;
          maven)
            cat > "$PKG_DIR/$PKG_NAME-$PKG_VERSION.pom" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <project>
          <groupId>com.test</groupId>
          <artifactId>$PKG_NAME</artifactId>
          <version>$PKG_VERSION</version>
          <description>MALWARE TEST SAMPLE - DO NOT USE IN PRODUCTION</description>
        </project>
        EOF
            ;;
          go)
            cat > "$PKG_DIR/go.mod" << EOF
        module github.com/test/$PKG_NAME
        
        // MALWARE TEST SAMPLE - DO NOT USE IN PRODUCTION
        go 1.21
        EOF
            ;;
          nuget)
            cat > "$PKG_DIR/$PKG_NAME.nuspec" << EOF
        <?xml version="1.0"?>
        <package>
          <metadata>
            <id>$PKG_NAME</id>
            <version>$PKG_VERSION</version>
            <description>MALWARE TEST SAMPLE - DO NOT USE IN PRODUCTION</description>
          </metadata>
        </package>
        EOF
            ;;
        esac
        
        # Sample catalog - simple approach without associative arrays
        # These are actual malware samples - use for testing only!
        
        # Determine which samples to download
        SAMPLES_TO_DOWNLOAD=""
        if [[ "$SAMPLES" == "all" ]]; then
          SAMPLES_TO_DOWNLOAD="obfuscated-js elf-malware pe-malware"
        else
          SAMPLES_TO_DOWNLOAD=$(echo "$SAMPLES" | tr ',' ' ')
        fi
        
        echo "Samples to inject: $SAMPLES_TO_DOWNLOAD"
        echo ""
        
        INJECTED_COUNT=0
        INJECTED_FILES=""
        
        # Function to get sample info
        get_sample_info() {
          case "$1" in
            obfuscated-js)
              echo "cbb9bc5a8496243e02f3cc080efbe3e4a1430ba0671f2e43a202bf45b05479cd|bun_environment.js|Shai Hulud obfuscated JavaScript backdoor"
              ;;
            elf-malware)
              echo "7f20b9e8235746e29e853a4793f64b2a02cf6a4eeca56fd3bd1e110bb4a84b0e|neotyxa.elf|Neotyxa ELF Linux malware binary"
              ;;
            pe-malware)
              echo "d44d8b0c31c580c97d2e781b9b2feebde81ad7e4ae79df2eea9d5f97d0b0e2c8|malware_sample.exe|Windows PE malware sample"
              ;;
            *)
              echo ""
              ;;
          esac
        }
        
        for SAMPLE_TYPE in $SAMPLES_TO_DOWNLOAD; do
          SAMPLE_INFO=$(get_sample_info "$SAMPLE_TYPE")
          
          if [[ -z "$SAMPLE_INFO" ]]; then
            echo "âš  Unknown sample type: $SAMPLE_TYPE"
            continue
          fi
          
          FILE_HASH=$(echo "$SAMPLE_INFO" | cut -d'|' -f1)
          FILE_NAME=$(echo "$SAMPLE_INFO" | cut -d'|' -f2)
          FILE_DESC=$(echo "$SAMPLE_INFO" | cut -d'|' -f3)
          
          echo "ðŸ“¥ Downloading: $FILE_DESC"
          echo "   Hash: $FILE_HASH"
          echo "   Target: $PKG_DIR/$FILE_NAME"
          
          HTTP_CODE=$(curl -s -w "%{http_code}" \
            -o "$PKG_DIR/$FILE_NAME" \
            "https://api.unknowncyber.com/v2/files/${FILE_HASH}/download/?key=${UC_API_KEY}" 2>/dev/null || echo "000")
          
          if [[ "$HTTP_CODE" == "200" ]]; then
            FILE_SIZE=$(stat -c%s "$PKG_DIR/$FILE_NAME" 2>/dev/null || stat -f%z "$PKG_DIR/$FILE_NAME" 2>/dev/null || echo "0")
            echo "   âœ“ Downloaded ($FILE_SIZE bytes)"
            INJECTED_COUNT=$((INJECTED_COUNT + 1))
            if [[ -n "$INJECTED_FILES" ]]; then
              INJECTED_FILES="$INJECTED_FILES,$PKG_DIR/$FILE_NAME"
            else
              INJECTED_FILES="$PKG_DIR/$FILE_NAME"
            fi
          else
            echo "   âœ— Failed (HTTP $HTTP_CODE)"
            # Create a placeholder for failed downloads
            echo "MALWARE_SAMPLE_PLACEHOLDER: $FILE_DESC" > "$PKG_DIR/$FILE_NAME.placeholder"
          fi
          echo ""
        done
        
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Injection Summary:"
        echo "  Samples injected: $INJECTED_COUNT"
        echo "  Package location: $PKG_DIR"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        
        # List injected files
        echo "Contents of $PKG_DIR:"
        ls -la "$PKG_DIR/" || true
        echo ""
        
        if command -v file &> /dev/null; then
          echo "File types:"
          file "$PKG_DIR"/* 2>/dev/null || true
        fi
        
        # Set outputs
        echo "path=$PKG_DIR" >> $GITHUB_OUTPUT
        echo "count=$INJECTED_COUNT" >> $GITHUB_OUTPUT
        echo "files=$INJECTED_FILES" >> $GITHUB_OUTPUT

    - name: Skip injection (disabled)
      if: inputs.enabled != 'true'
      shell: bash
      run: |
        echo "Malware test injection is disabled (enabled=${{ inputs.enabled }})"
